# 空间四叉树（QuadTree）设计文档

> 参考文献：https://pvigier.github.io/2019/08/04/quadtree-collision-detection.html

---

## 一、概述

### 1.1 什么是四叉树？

四叉树（QuadTree）是一种将二维空间**递归等分为四个象限**的树形数据结构。每个内部节点恰好有四个子节点，分别对应空间的四个象限：

```
         ┌───────┬───────┐
         │  TL   │  TR   │
         │ (左上) │ (右上) │
         ├───────┼───────┤
         │  BL   │  BR   │
         │ (左下) │ (右下) │
         └───────┴───────┘
```

### 1.2 应用场景

- 游戏中的**碰撞检测**：快速筛选可能碰撞的对象对
- **空间查询**：查找某区域内的所有对象
- 地图**视野裁剪**：只渲染摄像机范围内的对象
- 物理引擎中的**宽阶段（Broad Phase）** 碰撞检测

### 1.3 为什么不用暴力遍历？

对于 $n$ 个对象的碰撞检测：
- 暴力法：两两比较，$O(n^2)$
- 四叉树：空间局部性加速，平均 $O(n \log n)$

---

## 二、核心数据结构

### 2.1 AABBBox — 轴对齐包围盒

```csharp
public struct AABBBox
{
    public float2 Center;
    public float2 Size;
    public float2 Min;  // 左下角
    public float2 Max;  // 右上角
}
```

`AABBBox`（Axis-Aligned Bounding Box）是四叉树中所有空间计算的基础。它用一个矩形框来表示对象在2D空间中的范围。

**关键方法**：
- `Contains(AABBBox other)` — 判断一个盒子是否完全包含另一个盒子
- `Intersects(AABBBox other)` — 判断两个盒子是否有任何重叠

### 2.2 IBoundable — 可获取包围盒的对象接口

```csharp
public interface IBoundable
{
    public AABBBox GetBoundaryBox();
}
```

四叉树中存储的所有元素都必须实现此接口，以便树能获取其空间位置。这是四叉树与具体业务对象之间的**解耦点**。

### 2.3 TreeNode — 树节点

```csharp
public class TreeNode
{
    public TreeNode Parent;        // 父节点
    public TreeNode[] Children;    // 4个子节点 [TR, TL, BL, BR]
    internal List<T> Values;       // 存储在此节点的值
    public int Depth;              // 节点深度
    public AABBBox NodeBox;        // 节点覆盖的空间范围
}
```

**核心设计**：
- **叶子节点判定**：通过 `Children[0] == null` 判断。因为分裂时4个子节点同时创建，所以只需检查一个。
- **值的存储位置**：值不一定存储在叶子节点。如果一个对象跨越了中心线、无法完全归入任何一个象限，它会留在**父节点**中。
- **对象池管理**：`TreeNode` 实现了 `ISetupable / IClearable / IDisposable`，通过 `SimplePool<TreeNode>` 管理生命周期，减少 GC 压力。

---

## 三、核心算法

### 3.1 象限判定 — `GetBoxQuadrant`

这是四叉树最基础的操作：判断一个值的包围盒完全落在父节点的哪个象限。

```csharp
private static int GetBoxQuadrant(AABBBox nodeBox, AABBBox valueBox)
{
    if (valueBox.Right < nodeBox.Center.x)       // 完全在左半区
    {
        if (valueBox.Bottom > nodeBox.Center.y)       // 完全在上半区 → TL
        else if (valueBox.Top <= nodeBox.Center.y)     // 完全在下半区 → BL
    }
    else if (valueBox.Left >= nodeBox.Center.x)  // 完全在右半区
    {
        if (valueBox.Bottom > nodeBox.Center.y)       // → TR
        else if (valueBox.Top <= nodeBox.Center.y)     // → BR
    }
    // 以上都不满足 → 返回 -1（跨越中心线，无法归入任一象限）
}
```

**边界约定**：
- X轴：左半区使用严格 `<`，右半区使用 `>=`（右半区含中心线）
- Y轴：下半区使用 `<=`，上半区使用严格 `>`（下半区含中心线）
- 跨越任意中心线的对象返回 `-1`，留在当前节点

```
         ┌─────────┬─────────┐
         │  TL     │     TR  │
         │ R<cx    │ L>=cx   │
         │ B>cy    │ B>cy    │
         ├─────────┼─────────┤
         │  BL     │     BR  │
         │ R<cx    │ L>=cx   │
         │ T<=cy   │ T<=cy   │
         └─────────┴─────────┘
              cx = center.x
              cy = center.y
```

### 3.2 插入（Add / _AddValue）

```
Add(value):
  AddValue(root, value)
  _valueList.Add(value)    ← 维护全局值列表（用于重建和查询Count）
```

**`AddValue` 递归逻辑**：

```
AddValue(node, value):
  Assert: node.Box 必须包含 value.Box

  如果 node 是叶子节点:
    如果 depth >= MaxDepth 或 node.Values.Count < ValueThreshold:
      → 直接插入到 node.Values
    否则:
      → 分裂节点(SplitNode)
      → 递归重试 AddValue(node, value)

  如果 node 是内部节点:
    quadrant = GetBoxQuadrant(node.Box, value.Box)
    如果 quadrant != -1:
      → 递归插入到对应子节点
    否则（跨象限）:
      → 插入到 node.Values（留在当前节点）
```

**算法要点**：
- 叶子节点满了才分裂（**延迟分裂**），避免空节点浪费
- 达到 `MaxDepth` 后停止分裂，防止极端情况下无限递归
- 跨象限的值存储在能完全包含它的最深节点中

### 3.3 分裂（_SplitNode）

当叶子节点的值数量达到 `ValueThreshold` 时触发分裂：

```csharp
private void SplitNode(TreeNode leafNode, AABBBox nodeBox, int depth)
{
    // 1. 创建4个子节点，每个覆盖父节点的1/4空间
    for (int i = 0; i < 4; i++)
    {
        var node = _nodePool.Pop();
        node.Setup(_ComputeBox(nodeBox, i), depth, leafNode, i);
        leafNode.Children[i] = node;
    }

    // 2. 原地压缩：重新分配现有值
    int writeIdx = 0;
    for (int i = 0; i < leafNode.Values.Count; i++)
    {
        var idx = GetBoxQuadrant(nodeBox, val.GetBoundaryBox());
        if (idx != -1)
            leafNode.Children[idx].Values.Add(val);  // 移入子节点
        else
            leafNode.Values[writeIdx++] = val;        // 保留在当前节点
    }
    leafNode.Values.RemoveRange(writeIdx, ...);       // 裁剪尾部
}
```

**设计亮点** — 原地压缩：
- 不创建新 `List<T>`，避免每次分裂产生 GC 垃圾
- 使用"写指针"模式：遍历一遍完成分配+压缩，时间复杂度 $O(n)$

子节点空间计算如下：
```
         ┌────────────────────┐
         │                    │
         │   min      center  │
         │    ┌────┬────┐     │
         │    │ BL │ BR │     │
         │    ├────┼────┤     │
         │    │ TL │ TR │     │
         │    └────┴────┘     │
         │  center      max   │
         │                    │
         └────────────────────┘

  TR = AABBBox(center, max)
  TL = AABBBox((min.x, center.y), (center.x, max.y))
  BL = AABBBox(min, center)
  BR = AABBBox((center.x, min.y), (max.x, center.y))
```

### 3.4 删除（Remove / _RemoveValue）

```
Remove(value):
  1. 先从 _valueList 中移除（作为"值是否存在"的判定）
  2. 再从树结构中递归删除
  3. 删除后尝试向上合并
```

**`RemoveValue` 递归逻辑**：

```
RemoveValue(node, value):
  如果 node 是叶子节点:
    → 直接从 node.Values 移除

  如果 node 是内部节点:
    quadrant = GetBoxQuadrant(node.Box, value.Box)
    如果 quadrant != -1:
      → 递归进入子节点删除
      → 删除成功后尝试 TryMerge(node)
    否则:
      → 值在当前节点，直接移除
```

### 3.5 合并（_tryMerge）

合并是分裂的逆操作。当子节点的值被删除后，检查是否可以将子节点合并回父节点：

```csharp
private bool TryMerge(TreeNode node)
{
    // 条件1: 所有子节点都必须是叶子节点
    // 条件2: 当前节点 + 所有子节点的值总数 <= ValueThreshold
    if (满足条件)
    {
        // 将所有子节点的值收回到当前节点
        // 回收子节点到对象池
        // 返回 true，让父节点也尝试合并
    }
}
```

**为什么需要合并？** 如果只分裂不合并，随着对象移动和删除，树会变得稀疏，节点空间浪费，遍历效率下降。

### 3.6 区域查询（Query）

查找与给定区域 `queryBox` 相交的所有值：

```
Query(node, queryBox, retList):
  1. 检查当前节点自身存储的值是否与 queryBox 相交
  2. 如果是内部节点，检查每个子节点的空间范围是否与 queryBox 相交
     → 只递归进入有交集的子节点（空间剪枝）
```

**空间剪枝**是四叉树高效的关键：
- 如果 `queryBox` 只与一个象限相交，则 3/4 的子树被直接跳过
- 平均时间复杂度 $O(\log n + k)$，$k$ 为结果数量

### 3.7 碰撞检测（FindAllIntersections）

查找树中所有两两相交的对象对：

```
FindAllIntersections(node, retList):
  // 第一层：同一节点内的值两两检测
  for i in 0..n:
    for j in (i+1)..n:    ← j从i+1开始，避免重复对 (A,B)/(B,A) 和自身比较
      if intersects → add (i, j)

  // 第二层：当前节点的值 vs 所有子孙节点的值
  for each value in node.Values:
    for each child:
      _FindIntersectionsInDescendants(child, value, retList)

  // 第三层：递归处理每个子节点
  for each child:
    FindAllIntersections(child, retList)
```

**算法正确性保证**：
- 相交只可能发生在：(a) 同一节点内的两个值之间；(b) 一个值与其子孙节点中的值之间
- 同一象限内的两个值由递归处理
- 不同象限的值不可能相交（空间上不重叠）
- 跨象限的值存储在父节点，通过第二层与子孙进行检测

### 3.8 动态更新（UpdateValue / RebuildTree）

当对象移动后，需要更新其在树中的位置。提供两种策略：

#### 策略1: 局部更新（UpdateValue）

```
UpdateTreePartially(value):
  node = Find(value)  // O(n) 线性查找，因为value的AABB已变化，无法用象限加速

  情况1: 当前节点仍然包含新位置
    1.1: 无法归入任何象限 → 不需要移动
    1.2: 可归入某象限 → 从当前节点移除，尝试合并，添加到目标子节点

  情况2: 新位置超出当前节点范围
    → 从当前节点移除，沿父链向上查找能包含新位置的祖先节点
    → 在祖先节点中重新插入
```

#### 策略2: 全量重建（RebuildTree）

```
RebuildTree():
  tempValues = copy(_valueList)
  ClearTree()                    // 清空树结构，回收所有节点到池
  for each val in tempValues:
    Add(val)                     // 重新插入
```

#### 策略选择（UpdateValues）

```csharp
public void UpdateValues(List<T> updateList)
{
    if (updateList.Count < _valueList.Count * RebuildThreshold)
        → 逐个局部更新（少量移动时高效）
    else
        → 全量重建（大量移动时更快，避免反复Find）
}
```

**`RebuildThreshold`** 控制切换点：当更新列表长度超过总元素数的指定倍数时，认为局部更新的 `Find` 开销已超过全量重建的成本。

---

## 四、公共 API 一览

```csharp
// 构造
QuadTree(AABBBox rootBox, int valueThreshold = 16, int maxDepth = 8, float rebuildThreshold = 1.5f)

// 增删查
void    Add(T value)                           // 添加元素
bool    Remove(T value)                        // 移除元素
bool    Contains(T value)                      // 是否包含元素
int     Count                                  // 元素总数

// 空间查询
List<T> Query(AABBBox queryBox)                // 区域查询（返回新列表）
void    Query(AABBBox queryBox, List<T> ret)   // 区域查询（写入已有列表，避免GC）

// 碰撞检测
List<KeyValuePair<T,T>> FindAllIntersections()
void FindAllIntersections(List<KeyValuePair<T,T>> ret)

// 更新
void UpdateValue(T value)                      // 局部更新单个元素
void UpdateValues(List<T> list)                // 批量更新（自动选择局部/全量）
void RebuildTree()                             // 强制全量重建

// 查找
TreeNode Find(T value)                         // 查找值所在的节点

// 生命周期
void ClearTree()                               // 清空树（保留根节点）
void Dispose()                                 // 释放全部资源
```

---

## 五、参数调优指南

| 参数 | 默认值 | 说明 |
|------|--------|------|
| `valueThreshold` | 16 | 越大 → 树越浅、节点越胖；越小 → 树越深、查询越精确但开销越大 |
| `maxDepth` | 8 | 防止极端密集区域无限分裂。$4^8 = 65536$ 个叶子节点已足够精细 |
| `rebuildThreshold` | 1.5 | 当更新量 > 总量 × 系数时切换到全量重建 |

**经验法则**：
- 对象大小均匀且密度均匀 → 较小的 `valueThreshold`（4~8）
- 对象大小差异大或分布不均 → 较大的 `valueThreshold`（16~32）
- 树区域非常大但对象集中在小区域 → 减小 `maxDepth` 避免浪费
- 对象频繁移动（如游戏中每帧更新） → 可适当增大 `rebuildThreshold` 倾向使用局部更新

---

## 六、设计优化记录

### 6.1 从 const 到可配置参数

**改动前**：
```csharp
public const int VALUE_THRESHOLD = 16;
public const int MAX_DEPTH = 8;
```

**改动后**：
```csharp
public int ValueThreshold { get; }
public int MaxDepth { get; }

public QuadTree(AABBBox rootBox, int valueThreshold = 16, int maxDepth = 8, ...)
```

**原因**：作为通用工具，不同应用场景需要不同的参数。使用 `const` 意味着所有实例共享同一设置，无法根据场景调整。通过构造函数参数 + 默认值，既保持了使用便捷性，又提供了灵活性。

### 6.2 IBoundable 接口独立

**改动前**：`IBoundable` 定义在 `QuadTree.cs` 内部

**改动后**：移至 `AABBBox.cs`

**原因**：`IBoundable` 是一个通用的空间接口，可能被四叉树以外的模块（如八叉树、KD树等）复用。定义在 `QuadTree.cs` 内部会造成不必要的依赖。

### 6.3 TreeNode.Values 访问控制

**改动前**：`public List<T> Values { get; internal set; }`

**改动后**：
```csharp
internal List<T> Values { get; private set; }          // 内部写操作
public IReadOnlyList<T> NodeValues => Values;          // 外部只读视图
```

**原因**：暴露可变 `List<T>` 给外部代码，任何人都可以 `node.Values.Add(...)` 绕过树的管理逻辑，破坏数据一致性。通过 `IReadOnlyList<T>` 提供只读视图，保证数据只能通过树的公共 API 修改。

### 6.4 SplitNode 零分配优化

**改动前**：
```csharp
var newList = new List<T>();  // 每次分裂堆分配一个新List
...
leafNode.Values = newList;    // 旧List成为GC垃圾
```

**改动后**：使用原地压缩（In-Place Compaction）模式：
```csharp
int writeIdx = 0;
for (int i = 0; i < leafNode.Values.Count; i++)
{
    if (可分配到子节点)
        子节点.Values.Add(val);
    else
        leafNode.Values[writeIdx++] = val;  // 写指针前移
}
leafNode.Values.RemoveRange(writeIdx, ...);  // 裁剪尾部
```

**原因**：在游戏运行时频繁触发分裂会持续分配小对象，加重 GC 负担。原地压缩完全避免了中间容器的分配。

### 6.5 UpdateTree API 重构

**改动前**：
```csharp
void UpdateTree(T value)           // null 表示全量重建（魔术值）
void UpdateTree(List<T> list)      // null/空列表也触发全量重建
```

**改动后**：
```csharp
void UpdateValue(T value)          // 明确：局部更新单个值
void UpdateValues(List<T> list)    // 明确：批量更新，自动选择策略
void RebuildTree()                 // 明确：全量重建
```

**原因**：
- 使用 `null` 作为"全量重建"的语义是**隐式约定**，调用者必须阅读文档才知道
- 语义分离后，每个方法的意图一目了然
- `RebuildTree()` 公开后，调用者可以在已知需要全量重建时直接调用，无需传 null

### 6.6 移除 TreeNode.Address

**改动前**：`Address = Parent.Address * 10 + ChildIdx`

**问题**：
- 十进制编码：子节点索引 0-3 占一位十进制，`MaxDepth=8` 时 `Address` 最大可到 `03333333`（约 3000 万），接近 `int.MaxValue` 上限
- 如果增大 `MaxDepth` 到 10+，会溢出
- 实际上从未在外部使用过

**建议**：如果确实需要节点路径信息，推荐使用位编码（每层2 bit），支持最深16层且不溢出：
```csharp
// 示例：Address = Parent.Address << 2 | ChildIdx
```

### 6.7 移除 _valueListCopy 字段

**改动前**：`_valueListCopy` 作为类字段常驻内存

**改动后**：`RebuildTree()` 中使用局部变量 `var tempValues = new List<T>(_valueList)`

**原因**：`_valueListCopy` 只在 `RebuildTree` 中使用，却始终占据内存。重建操作本身就是低频的重量级操作，额外一次 List 分配对其整体性能无影响。
